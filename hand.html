<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>両手操作デモ（USBカメラ対応・Hand安定版）</title>
  <link rel="icon" href="data:,">

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    body { margin:0; overflow:hidden; background:#000; font-family: system-ui, -apple-system, "Hiragino Sans", sans-serif; }
    #wrap { position: fixed; inset: 0; }
    canvas { display:block; width:100%; height:100%; }

    #video { position: fixed; right: 10px; bottom: 10px; width: 180px; height: 135px; opacity: 0; pointer-events:none; }
    /* デバッグで映像を見たければ opacity を 0.35 などに */

    #hud {
      position: fixed; left: 12px; top: 12px; right: 12px;
      display:flex; justify-content: space-between; gap: 12px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(8px);
      color: #e8eef6;
      font-size: 12px;
      white-space: pre-wrap;
      align-items: flex-start;
    }

    #ctrl { display:flex; gap: 8px; align-items: center; flex-wrap: wrap; justify-content: flex-end; max-width: 60vw; }

    select, button {
      font-size: 14px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(20,60,120,.6);
      color: #fff;
    }
    select { background: rgba(20,60,120,.35); }
  </style>
</head>

<body>
  <div id="wrap"></div>
  <video id="video" autoplay playsinline muted></video>

  <div id="hud">
    <div id="status">起動中…</div>
    <div id="ctrl">
      <select id="camSelect" title="カメラを選択"></select>
      <button id="btnApply">このカメラで開始</button>
      <button id="btnFS">全画面</button>
    </div>
  </div>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

const wrap = document.getElementById("wrap");
const statusEl = document.getElementById("status");
const video = document.getElementById("video");
const camSelect = document.getElementById("camSelect");
const btnApply = document.getElementById("btnApply");
const btnFS = document.getElementById("btnFS");

btnFS.addEventListener("click", async () => {
  try { await document.documentElement.requestFullscreen(); } catch {}
});

// ===== 設定 =====
const MODEL_URL = "./vitruvian.glb";
const HAND_NEAR_SIZE = 0.16;     // 「近い」判定。検出が0の問題には直接関係しない（検出が出てから効く）
const MAX_YAW = Math.PI * 0.35;
const MAX_PITCH = Math.PI * 0.20;
const MAX_ROLL = Math.PI * 0.08;
const ROT_SMOOTH = 0.12;
const MODEL_SCALE = 1.0;

// ===== three.js =====
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
wrap.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
camera.position.set(0, 0.1, 2.5);

const root = new THREE.Group();
scene.add(root);

scene.add(new THREE.AmbientLight(0xffffff, 0.25));
const key = new THREE.DirectionalLight(0xffffff, 2.6);
key.position.set(1.2, 1.6, 1.8);
scene.add(key);
const rim = new THREE.DirectionalLight(0xbfdcff, 1.6);
rim.position.set(-1.4, 0.6, -1.6);
scene.add(rim);

// モデル
let model = null;
async function loadModel() {
  const loader = new GLTFLoader();
  try {
    const gltf = await loader.loadAsync(MODEL_URL);
    model = gltf.scene;
    root.add(model);

    const box = new THREE.Box3().setFromObject(model);
    const size = new THREE.Vector3(); box.getSize(size);
    const center = new THREE.Vector3(); box.getCenter(center);
    model.position.sub(center);

    const maxDim = Math.max(size.x, size.y, size.z, 1e-6);
    const norm = 1.3 / maxDim;
    model.scale.setScalar(norm * MODEL_SCALE);
    model.position.y += 0.05;

    model.traverse(o => {
      if (!o.isMesh || !o.material) return;
      const m = o.material;
      if ("roughness" in m) m.roughness = Math.min(m.roughness, 0.7);
      if ("metalness" in m) m.metalness = Math.max(m.metalness ?? 0, 0.05);
      if ("emissive" in m) {
        m.emissive = m.emissive || new THREE.Color(0x000000);
        m.emissiveIntensity = Math.max(m.emissiveIntensity ?? 0, 0.05);
      }
      m.needsUpdate = true;
    });

  } catch (e) {
    console.warn(e);
    const geo = new THREE.TorusKnotGeometry(0.38, 0.14, 180, 24);
    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.45, metalness: 0.2 });
    model = new THREE.Mesh(geo, mat);
    root.add(model);
  }
}

// ===== MediaPipe HandLandmarker =====
const MP_VER = "0.10.22-rc.20250304";
const { HandLandmarker, FilesetResolver } = await import(
  `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@${MP_VER}/vision_bundle.mjs`
);

let handLandmarker = null;
let stream = null;
let usingDelegate = "GPU";

async function initHandLandmarkerWithFallback() {
  const vision = await FilesetResolver.forVisionTasks(
    `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@${MP_VER}/wasm`
  );

  // まずGPU、ダメならCPUにフォールバック
  try {
    usingDelegate = "GPU";
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath:
          "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
        delegate: "GPU"
      },
      runningMode: "VIDEO",
      numHands: 2,
      minHandDetectionConfidence: 0.3,
      minHandPresenceConfidence: 0.3,
      minTrackingConfidence: 0.3
    });
    return;
  } catch (e) {
    console.warn("GPU delegate failed, fallback to CPU", e);
  }

  usingDelegate = "CPU";
  handLandmarker = await HandLandmarker.createFromOptions(vision, {
    baseOptions: {
      modelAssetPath:
        "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
      delegate: "CPU"
    },
    runningMode: "VIDEO",
    numHands: 2,
    minHandDetectionConfidence: 0.3,
    minHandPresenceConfidence: 0.3,
    minTrackingConfidence: 0.3
  });
}

// ★ カメラ許可 → デバイス一覧取得
async function primeAndListCameras() {
  const tmp = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
  tmp.getTracks().forEach(t => t.stop());

  const devices = await navigator.mediaDevices.enumerateDevices();
  const cams = devices.filter(d => d.kind === "videoinput");

  camSelect.innerHTML = "";
  cams.forEach((c, i) => {
    const opt = document.createElement("option");
    opt.value = c.deviceId;
    opt.textContent = c.label || `Camera ${i+1}`;
    camSelect.appendChild(opt);
  });

  if (cams.length === 0) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "カメラが見つかりません";
    camSelect.appendChild(opt);
    camSelect.disabled = true;
    btnApply.disabled = true;
  }
}

async function startSelectedCamera(deviceId) {
  if (stream) stream.getTracks().forEach(t => t.stop());

  const constraints = {
    audio: false,
    video: deviceId ? { deviceId: { exact: deviceId } } : true
  };
  stream = await navigator.mediaDevices.getUserMedia(constraints);
  video.srcObject = stream;

  // iOS対策：再生開始を明示
  await video.play();

  // デバッグ：実際の解像度
  const track = stream.getVideoTracks()[0];
  const s = track?.getSettings?.() || {};
  return s;
}

// ===== 手情報 =====
function bboxFromLandmarks(lm) {
  let minX =  1e9, minY =  1e9;
  let maxX = -1e9, maxY = -1e9;
  for (const p of lm) {
    if (p.x < minX) minX = p.x;
    if (p.y < minY) minY = p.y;
    if (p.x > maxX) maxX = p.x;
    if (p.y > maxY) maxY = p.y;
  }
  const cx = (minX + maxX) * 0.5;
  const cy = (minY + maxY) * 0.5;
  const size = Math.max(maxX - minX, maxY - minY);
  return { cx, cy, size };
}
function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

let targetYaw=0, targetPitch=0, targetRoll=0;
let curYaw=0, curPitch=0, curRoll=0;

function computeTargetsFromHands(hands) {
  const near = hands.filter(h => h.size >= HAND_NEAR_SIZE);
  if (near.length === 0) return { active:false, nearCount:0, handSizes:hands.map(h=>h.size) };

  if (near.length === 1) {
    const h = near[0];
    const nx = (h.cx - 0.5) * 2;
    const ny = (0.5 - h.cy) * 2;
    targetYaw = clamp(nx * MAX_YAW, -MAX_YAW, MAX_YAW);
    targetPitch = clamp(ny * MAX_PITCH, -MAX_PITCH, MAX_PITCH);
    targetRoll = 0;
    return { active:true, nearCount:1, handSizes:hands.map(h=>h.size) };
  }

  near.sort((a,b)=>b.size-a.size);
  const h1 = near[0], h2 = near[1];

  const mx = (h1.cx + h2.cx) * 0.5;
  const my = (h1.cy + h2.cy) * 0.5;

  const nx = (mx - 0.5) * 2;
  const ny = (0.5 - my) * 2;

  targetYaw = clamp(nx * MAX_YAW, -MAX_YAW, MAX_YAW);
  targetPitch = clamp(ny * MAX_PITCH, -MAX_PITCH, MAX_PITCH);

  const dx = (h2.cx - h1.cx);
  const dy = (h2.cy - h1.cy);
  const ang = Math.atan2(dy, dx);
  targetRoll = clamp(ang * 0.35, -MAX_ROLL, MAX_ROLL);

  return { active:true, nearCount:2, handSizes:hands.map(h=>h.size) };
}

// ===== ループ =====
let lastFrameTs = 0;
let lastHandsCount = 0;

function resizeIfNeeded() {
  const w = wrap.clientWidth, h = wrap.clientHeight;
  const pr = renderer.getPixelRatio();
  if (renderer.domElement.width !== Math.floor(w * pr) || renderer.domElement.height !== Math.floor(h * pr)) {
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
}

// Safari/iOS向け：requestVideoFrameCallback が使えればそれで回す
function onVideoFrame(now, metadata) {
  tick(now);
  if (video.requestVideoFrameCallback) video.requestVideoFrameCallback(onVideoFrame);
}

function rafLoop() {
  tick(performance.now());
  requestAnimationFrame(rafLoop);
}

function tick(now) {
  resizeIfNeeded();

  let active = false;
  let nearCount = 0;
  let handSizes = [];
  let handsCount = 0;

  if (handLandmarker && video.readyState >= 2) {
    // requestVideoFrameCallback の場合でも detectForVideo に now を渡す
    const res = handLandmarker.detectForVideo(video, now);
    const lms = res.handLandmarks || [];
    handsCount = lms.length;

    if (handsCount > 0) {
      const hands = lms.map(bboxFromLandmarks);
      const r = computeTargetsFromHands(hands);
      active = r.active;
      nearCount = r.nearCount;
      handSizes = r.handSizes;
    }
  }

  // スムージング
  curYaw += (targetYaw - curYaw) * ROT_SMOOTH;
  curPitch += (targetPitch - curPitch) * ROT_SMOOTH;
  curRoll += (targetRoll - curRoll) * ROT_SMOOTH;

  if (model) {
    if (!active) {
      targetYaw *= 0.96;
      targetPitch *= 0.96;
      targetRoll *= 0.92;
    }
    root.rotation.set(curPitch, curYaw, curRoll);
  }

  lastHandsCount = handsCount;

  statusEl.textContent =
    `両手操作デモ（USBカメラ対応・Hand安定版）\n` +
    `選択カメラ: ${camSelect.selectedOptions[0]?.textContent ?? "-"}\n` +
    `Hand delegate: ${usingDelegate}\n` +
    `検出: ${handsCount}手 / 近い判定: ${nearCount}手（しきい値=${HAND_NEAR_SIZE}）\n` +
    `手size: ${handSizes.length ? handSizes.map(s=>s.toFixed(3)).join(", ") : "-"}\n` +
    `角度: yaw=${curYaw.toFixed(2)} pitch=${curPitch.toFixed(2)} roll=${curRoll.toFixed(2)}\n` +
    `ヒント: 検出が0のまま→ USBカメラを別の候補に切替 / delegate=CPUで改善することが多い`;

  renderer.render(scene, camera);
}

// ===== boot =====
(async function boot(){
  try {
    statusEl.textContent = "起動中…（モデル読み込み）";
    await loadModel();

    statusEl.textContent = "カメラ許可→一覧取得中…（USBカメラも含まれます）";
    await primeAndListCameras();

    statusEl.textContent = "「このカメラで開始」を押してください。";
    btnApply.addEventListener("click", async () => {
      btnApply.disabled = true;
      try {
        statusEl.textContent = "カメラ開始中…";
        const s = await startSelectedCamera(camSelect.value);

        statusEl.textContent =
          `手認識初期化中…（GPU→CPUフォールバック）\n` +
          `camera: ${s.width ?? "?"}x${s.height ?? "?"}  fps=${s.frameRate ?? "?"}`;

        await initHandLandmarkerWithFallback();

        statusEl.textContent =
          `準備OK。手を近づけると角度が変わります。\n` +
          `delegate=${usingDelegate}`;

        if (video.requestVideoFrameCallback) video.requestVideoFrameCallback(onVideoFrame);
        else requestAnimationFrame(rafLoop);

      } catch (e) {
        console.error(e);
        statusEl.textContent = "エラー：USBカメラ・許可・接続を確認してください。\n" + String(e);
      } finally {
        btnApply.disabled = false;
      }
    });

  } catch (e) {
    console.error(e);
    statusEl.textContent = "エラー：HTTPS / カメラ許可 / Safari制限 / CDN を確認してください。\n" + String(e);
  }
})();
</script>
</body>
</html>
