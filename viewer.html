<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>奥行き錯覚テスト - Viewer</title>

  <link rel="icon" href="data:,">

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    :root { color-scheme: dark; }
    body { margin:0; overflow:hidden; background:#000; font-family: system-ui, -apple-system, "Hiragino Sans", sans-serif; }
    #wrap { position: fixed; inset: 0; }
    canvas { display:block; width:100%; height:100%; }

    #video { position: fixed; right: 8px; bottom: 8px; width: 160px; height: 120px; opacity: 0; pointer-events:none; }

    #hud{
      position: fixed; left: 12px; top: 12px; right: 12px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      background: rgba(0,0,0,.45); border: 1px solid rgba(255,255,255,.14);
      border-radius: 14px; padding: 10px 12px; backdrop-filter: blur(8px);
      color:#e8eef6; font-size: 13px;
    }
    #hud .left { display:flex; flex-direction:column; gap:2px; }
    #hud .title { font-weight: 700; font-size: 13px; }
    #hud .sub { opacity:.85; font-size: 12px; }
    #hud button {
      font-size: 14px; padding: 8px 10px; border-radius: 12px;
      border: 1px solid rgba(255,255,255,.18); background: rgba(20,60,120,.6); color: #fff;
    }

    #msg{
      position: fixed; left: 12px; bottom: 12px;
      background: rgba(0,0,0,.45); border: 1px solid rgba(255,255,255,.14);
      border-radius: 14px; padding: 10px 12px; color:#e8eef6; font-size: 12px;
      max-width: min(860px, calc(100vw - 24px));
      white-space: pre-wrap;
    }
  </style>
</head>

<body>
<div id="wrap"></div>
<video id="video" autoplay playsinline muted></video>

<div id="hud">
  <div class="left">
    <div class="title">奥行き錯覚テスト</div>
    <div id="status" class="sub">起動中…</div>
  </div>
  <div class="right">
    <button id="btnFS">全画面</button>
    <button id="btnBack">戻る</button>
  </div>
</div>

<div id="msg">起動中…</div>

<script type="module">
  import * as THREE from "three";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

  import { LineSegments2 } from "three/addons/lines/LineSegments2.js";
  import { LineSegmentsGeometry } from "three/addons/lines/LineSegmentsGeometry.js";
  import { LineMaterial } from "three/addons/lines/LineMaterial.js";

  const MP_VER = "0.10.22-rc.20250304";
  const { FaceLandmarker, FilesetResolver } = await import(
    `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@${MP_VER}/vision_bundle.mjs`
  );

  const wrap = document.getElementById("wrap");
  const statusEl = document.getElementById("status");
  const msgEl = document.getElementById("msg");
  const video = document.getElementById("video");

  document.getElementById("btnBack").addEventListener("click", () => history.back());
  document.getElementById("btnFS").addEventListener("click", async () => {
    try { await document.documentElement.requestFullscreen(); } catch {}
  });

  const qs = new URLSearchParams(location.search);
  const camMode = qs.get("camMode") || "front";
  const deviceId = qs.get("deviceId") || "";
  const modelParam = qs.get("model") || "__EMPTY_ROOM__";
  const isEmptyRoom = (modelParam === "__EMPTY_ROOM__");

  const roomType = (qs.get("room") || "checker").toLowerCase();
  const rotateEnabled = (qs.get("rotate") ?? "1") !== "0";

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.6;

  wrap.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const baseFov = 55;
  const camera = new THREE.PerspectiveCamera(baseFov, 1, 0.01, 50);

  // 部屋（20%小さく）
  const boxSize = 2.8 * 0.5;
  let roomGroup = null;

  let neonPrimaryMat = null;
  let neonHaloMat = null;

  // 荒い格子：4分割 → 内線3本
  const neonGridDiv = 4;
  const eps = 0.001;

  function makeCheckerWithBrightPatches({
    size = 1024,
    cells = 12,
    darkA = "#0f1722",
    darkB = "#141e2d",
    bright = "#cfe7ff",
    bright2 = "#ffffff"
  } = {}) {
    const c = document.createElement("canvas");
    c.width = c.height = size;
    const g = c.getContext("2d");

    const cell = size / cells;

    for (let y = 0; y < cells; y++) {
      for (let x = 0; x < cells; x++) {
        g.fillStyle = ((x + y) % 2 === 0) ? darkA : darkB;
        g.fillRect(x * cell, y * cell, cell, cell);
      }
    }

    const patches = Math.floor(cells * 1.2);
    for (let i = 0; i < patches; i++) {
      const px = Math.floor(Math.random() * cells);
      const py = Math.floor(Math.random() * cells);
      const w = (1 + Math.floor(Math.random() * 2)) * cell;
      const h = (1 + Math.floor(Math.random() * 2)) * cell;

      const x0 = px * cell;
      const y0 = py * cell;

      const grad = g.createRadialGradient(
        x0 + w * 0.5, y0 + h * 0.5, 0,
        x0 + w * 0.5, y0 + h * 0.5, Math.max(w, h) * 0.75
      );
      grad.addColorStop(0.0, bright2);
      grad.addColorStop(0.35, bright);
      grad.addColorStop(1.0, "rgba(207,231,255,0.0)");

      g.fillStyle = grad;
      g.fillRect(x0, y0, w, h);
    }

    const img = g.getImageData(0, 0, size, size);
    const d = img.data;
    for (let i = 0; i < d.length; i += 4) {
      const n = (Math.random() - 0.5) * 6;
      d[i]   = Math.max(0, Math.min(255, d[i]   + n));
      d[i+1] = Math.max(0, Math.min(255, d[i+1] + n));
      d[i+2] = Math.max(0, Math.min(255, d[i+2] + n));
    }
    g.putImageData(img, 0, 0);

    const tex = new THREE.CanvasTexture(c);
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(1.6, 1.6);
    tex.anisotropy = 8;
    return tex;
  }

  // ★ ネオン：外枠＋荒い格子（ただし「手前面の格子だけ無し」）
  function makeNeonEdgesGroup() {
    const g = new THREE.Group();
    const half = boxSize * 0.5;

    const positions = [];
    const pushSeg = (x1,y1,z1, x2,y2,z2) => positions.push(x1,y1,z1, x2,y2,z2);

    // 1) 外枠（必ず残す）
    {
      const geo = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
      const edges = new THREE.EdgesGeometry(geo);
      const arr = edges.attributes.position.array;
      for (let i = 0; i < arr.length; i++) positions.push(arr[i]);
    }

    // 2) 格子：各面に追加。ただし「手前面（Z=+側）」は追加しない
    const step = (2 * half) / neonGridDiv;

    // Z面：奥側のみ（Z=-half+eps）に格子を追加
    // ※カメラは通常 +Z 側から見ているので、Z=+ は「手前」
    {
      const z = -half + eps; // 奥
      for (let k = 1; k < neonGridDiv; k++) {
        const x = -half + step * k;
        pushSeg(x, -half, z,  x,  half, z);     // 縦（Y方向）
        const y = -half + step * k;
        pushSeg(-half, y, z,  half, y, z);      // 横（X方向）
      }
    }

    // X面：左右（両方）に格子
    for (const x of [half - eps, -half + eps]) {
      for (let k = 1; k < neonGridDiv; k++) {
        const z = -half + step * k;
        pushSeg(x, -half, z,  x,  half, z);     // 縦（Y方向）
        const y = -half + step * k;
        pushSeg(x, y, -half,  x, y,  half);     // 横（Z方向）
      }
    }

    // Y面：上下（両方）に格子
    for (const y of [half - eps, -half + eps]) {
      for (let k = 1; k < neonGridDiv; k++) {
        const x = -half + step * k;
        pushSeg(x, y, -half,  x, y,  half);     // 縦（X方向）
        const z = -half + step * k;
        pushSeg(-half, y, z,  half, y, z);      // 横（Z方向）
      }
    }

    const lineGeo = new LineSegmentsGeometry();
    lineGeo.setPositions(positions);

    neonPrimaryMat = new LineMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.95,
      linewidth: 10.0,
      worldUnits: false
    });

    neonHaloMat = new LineMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.20,
      linewidth: 20.0,
      worldUnits: false
    });

    const lines = new LineSegments2(lineGeo, neonPrimaryMat);
    const halo  = new LineSegments2(lineGeo, neonHaloMat);
    halo.scale.setScalar(1.003);

    g.add(halo);
    g.add(lines);
    return g;
  }

  function buildRoom(type) {
    const g = new THREE.Group();
    neonPrimaryMat = null;
    neonHaloMat = null;

    if (type === "neon") {
      g.add(makeNeonEdgesGroup());
      return g;
    }

    const wallTex = makeCheckerWithBrightPatches();
    const boxGeo = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
    const boxMat = new THREE.MeshStandardMaterial({
      map: wallTex,
      roughness: 0.75,
      metalness: 0.0,
      side: THREE.BackSide,
      emissive: new THREE.Color(0x0a0f16),
      emissiveIntensity: 0.35
    });
    g.add(new THREE.Mesh(boxGeo, boxMat));
    return g;
  }

  function setRoom(type) {
    if (roomGroup) scene.remove(roomGroup);
    roomGroup = buildRoom(type);
    scene.add(roomGroup);
  }

  setRoom(roomType);

  // 光源
  scene.add(new THREE.AmbientLight(0xffffff, roomType === "neon" ? 0.10 : 0.18));

  const spotKey = new THREE.SpotLight(0xffffff, 140, 30, Math.PI / 7, 0.35, 1.4);
  spotKey.position.set(0.8, 1.6, 2.3);
  scene.add(spotKey);
  scene.add(spotKey.target);

  const spotFill = new THREE.SpotLight(0xcfe7ff, 35, 30, Math.PI / 6, 0.5, 1.2);
  spotFill.position.set(-1.6, 0.9, 1.2);
  scene.add(spotFill);
  scene.add(spotFill.target);

  scene.add(new THREE.HemisphereLight(0xbfdcff, 0x080a0f, roomType === "neon" ? 0.35 : 0.55));

  const target = new THREE.Vector3(0, 0, 0);

  // カメラ制御
  const virtualEye = new THREE.Vector3(0, 0, 3.2);
  const frontZ = (boxSize * 0.5) - 0.01;

  const planeWidth = 1.9;
  const planeHeight = 1.2;

  const baseT = 0.62;

  const smoothPos = 0.18;
  const smoothFov = 0.10;

  let baselineSize = null;
  const zoomStrength = 0.55;
  const maxZoomFovDelta = 12;

  let locked = false;
  let lockCenter = { x: 0.5, y: 0.5 };
  let lockSize = 0.20;
  let lastGoodTime = performance.now();

  const LOST_HOLD_MS = 900;
  const MAX_ACCEPT_SCORE = 0.020;
  const SIZE_WEIGHT = 0.6;

  const desiredCamPos = new THREE.Vector3(0, 0, 2.25);
  const smoothedCamPos = new THREE.Vector3(0, 0, 2.25);
  let desiredFov = baseFov;
  let smoothedFov = baseFov;

  function head2DToFrontPlanePoint(cx01, cy01) {
    const nx = -((cx01 - 0.5) * 2);
    const ny = (0.5 - cy01) * 2;
    return new THREE.Vector3(
      nx * (planeWidth * 0.5),
      ny * (planeHeight * 0.5),
      frontZ
    );
  }

  function computeHeadFromLandmarks(landmarks) {
    let sx = 0, sy = 0;
    let minX =  1e9, minY =  1e9;
    let maxX = -1e9, maxY = -1e9;

    const n = landmarks.length;
    for (let i = 0; i < n; i++) {
      const p = landmarks[i];
      sx += p.x; sy += p.y;
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }

    const cx = sx / n;
    const cy = sy / n;

    const w = (maxX - minX);
    const h = (maxY - minY);
    const size = Math.max(w, h);

    return { center: { x: cx, y: cy }, size };
  }

  function pickLockedFace(faceLandmarksList) {
    const candidates = faceLandmarksList.map(lm => computeHeadFromLandmarks(lm));

    if (!locked) {
      let best = candidates[0];
      for (const c of candidates) if (c.size > best.size) best = c;

      locked = true;
      lockCenter = { x: best.center.x, y: best.center.y };
      lockSize = best.size;
      lastGoodTime = performance.now();

      baselineSize = best.size;

      return { center: lockCenter, size: lockSize, score: 0 };
    }

    let best = null;
    let bestScore = Infinity;

    for (const c of candidates) {
      const dx = c.center.x - lockCenter.x;
      const dy = c.center.y - lockCenter.y;
      const ds = c.size - lockSize;

      const score = (dx*dx + dy*dy) + SIZE_WEIGHT * (ds*ds);
      if (score < bestScore) {
        bestScore = score;
        best = c;
      }
    }

    if (!best || bestScore > MAX_ACCEPT_SCORE) return null;

    const a = 0.35;
    lockCenter = {
      x: lockCenter.x + (best.center.x - lockCenter.x) * a,
      y: lockCenter.y + (best.center.y - lockCenter.y) * a
    };
    lockSize = lockSize + (best.size - lockSize) * a;

    lastGoodTime = performance.now();
    return { center: lockCenter, size: lockSize, score: bestScore };
  }

  function applyLineOfSightCamera(headCenter, faceSize01) {
    const headPoint = head2DToFrontPlanePoint(headCenter.x, headCenter.y);

    const depthBoost = clamp((faceSize01 - 0.18) * 1.2, -0.12, 0.22);
    const t = clamp(baseT + depthBoost, 0.25, 0.92);
    desiredCamPos.lerpVectors(virtualEye, headPoint, t);

    if (baselineSize === null) {
      baselineSize = faceSize01;
      desiredFov = baseFov;
      return;
    }

    const ratio = faceSize01 / Math.max(1e-6, baselineSize);
    const approach = Math.max(0, ratio - 1);
    const fovDelta = clamp(approach * 30 * zoomStrength, 0, maxZoomFovDelta);
    desiredFov = baseFov - fovDelta;
  }

  // GLB
  const loader = new GLTFLoader();
  let modelRoot = null;
  let modelBaseY = 0.10;

  function normalizeAndPlaceModel(root) {
    const b = new THREE.Box3().setFromObject(root);
    const size = new THREE.Vector3();
    b.getSize(size);

    const maxDim = Math.max(size.x, size.y, size.z, 1e-6);
    const normalizeScale = 1.0 / maxDim;

    const finalScale = normalizeScale * 0.8;
    root.scale.setScalar(finalScale);

    const b2 = new THREE.Box3().setFromObject(root);
    const center = new THREE.Vector3();
    b2.getCenter(center);
    root.position.sub(center);

    root.position.y += modelBaseY;

    root.traverse((o) => {
      if (!o.isMesh) return;
      const m = o.material;
      if (!m) return;

      if ("roughness" in m) m.roughness = Math.min(m.roughness, 0.65);
      if ("metalness" in m) m.metalness = Math.max(m.metalness ?? 0, 0.05);

      if ("emissive" in m) {
        m.emissive = m.emissive || new THREE.Color(0x000000);
        m.emissiveIntensity = Math.max(m.emissiveIntensity ?? 0, 0.06);
      }
      m.needsUpdate = true;
    });
  }

  async function loadModelIfNeeded() {
    if (isEmptyRoom) {
      statusEl.textContent = `空っぽの部屋 / room=${roomType}`;
      return;
    }
    statusEl.textContent = "3Dモデル読み込み中…";

    const gltf = await loader.loadAsync(modelParam);
    modelRoot = gltf.scene;

    normalizeAndPlaceModel(modelRoot);
    scene.add(modelRoot);

    statusEl.textContent = `モデル表示中 / room=${roomType}`;
  }

  async function startCamera() {
    let constraints = { audio: false, video: {} };

    if (camMode === "usb") {
      constraints.video = deviceId ? { deviceId: { exact: deviceId } } : true;
    } else if (camMode === "back") {
      constraints.video = { facingMode: { ideal: "environment" } };
    } else {
      constraints.video = { facingMode: { ideal: "user" } };
    }

    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();
  }

  let faceLandmarker = null;
  let lastVideoTime = -1;

  async function initFaceLandmarker() {
    statusEl.textContent += " / 顔トラッキング初期化…";

    const vision = await FilesetResolver.forVisionTasks(
      `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@${MP_VER}/wasm`
    );

    faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
        delegate: "GPU"
      },
      runningMode: "VIDEO",
      numFaces: 3,
      outputFacialTransformationMatrixes: false,
      outputFaceBlendshapes: false
    });

    statusEl.textContent = (isEmptyRoom ? `空っぽの部屋 / room=${roomType}` : `モデル表示中 / room=${roomType}`) + " / ロック追跡ON";
  }

  function updateNeonLinewidth() {
    if (!neonPrimaryMat || !neonHaloMat) return;
    const d = camera.position.length();
    const primary = clamp(25 / Math.max(0.1, d), 2.0, 10.0);
    const halo = clamp(primary * 2.0, 4.0, 22.0);
    neonPrimaryMat.linewidth = primary;
    neonHaloMat.linewidth = halo;
  }

  const rotSpeed = 0.25;
  let lastT = performance.now();
  let lastScore = 0;

  function onFrame(now = performance.now()) {
    requestAnimationFrame(onFrame);

    const dt = Math.min(0.05, (now - lastT) / 1000);
    lastT = now;

    const w = wrap.clientWidth, h = wrap.clientHeight;

    const needResize =
      renderer.domElement.width !== Math.floor(w * renderer.getPixelRatio()) ||
      renderer.domElement.height !== Math.floor(h * renderer.getPixelRatio());

    if (needResize) {
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();

      if (neonPrimaryMat) neonPrimaryMat.resolution.set(w, h);
      if (neonHaloMat) neonHaloMat.resolution.set(w, h);
    }

    if (modelRoot && rotateEnabled) {
      modelRoot.rotation.y += rotSpeed * dt;
    }

    const focusY = modelRoot ? modelBaseY : 0.08;
    spotKey.target.position.set(0, focusY, 0);
    spotFill.target.position.set(0, focusY, 0);

    if (faceLandmarker && video.readyState >= 2 && video.currentTime !== lastVideoTime) {
      const ts = performance.now();
      const res = faceLandmarker.detectForVideo(video, ts);
      lastVideoTime = video.currentTime;

      const faces = res.faceLandmarks;

      if (faces && faces.length > 0) {
        const picked = pickLockedFace(faces);

        if (picked) {
          lastScore = picked.score;
          applyLineOfSightCamera(picked.center, picked.size);
        } else {
          if (now - lastGoodTime < LOST_HOLD_MS) {
            applyLineOfSightCamera(lockCenter, lockSize);
          } else {
            locked = false;
            baselineSize = null;
          }
        }
      } else {
        if (locked && (now - lastGoodTime < LOST_HOLD_MS)) {
          applyLineOfSightCamera(lockCenter, lockSize);
        } else {
          locked = false;
          baselineSize = null;
        }
      }
    }

    smoothedCamPos.lerp(desiredCamPos, smoothPos);
    camera.position.copy(smoothedCamPos);
    camera.lookAt(target);

    smoothedFov += (desiredFov - smoothedFov) * smoothFov;
    camera.fov = smoothedFov;
    camera.updateProjectionMatrix();

    updateNeonLinewidth();

    const ratio = (baselineSize === null) ? 1 : (lockSize / baselineSize);
    msgEl.textContent =
      `・room: ${roomType}（neon は手前面格子なし）\n` +
      `・回転: ${rotateEnabled ? "ON" : "OFF"}\n` +
      `・部屋サイズ: ${boxSize.toFixed(2)}\n` +
      `・ネオン太さ(px): ${neonPrimaryMat ? neonPrimaryMat.linewidth.toFixed(1) : "-"}\n` +
      `・格子分割: ${roomType === "neon" ? neonGridDiv + "（内線3本、手前面なし）" : "-"}\n` +
      `・ロック: ${locked ? "ON" : "OFF"}  score=${(lastScore ?? 0).toFixed(4)}\n` +
      `・顔サイズ: ${lockSize.toFixed(4)}  基準: ${baselineSize === null ? "未設定" : baselineSize.toFixed(4)}  ratio=${ratio.toFixed(3)}\n` +
      `・FOV: ${smoothedFov.toFixed(1)}\n` +
      `・表示: ${isEmptyRoom ? "空っぽ（モデルなし）" : modelParam.split("/").slice(-1)[0]}`;

    renderer.render(scene, camera);
  }

  (async function boot() {
    try {
      await loadModelIfNeeded();
      await startCamera();

      desiredCamPos.set(0, 0, 2.25);
      smoothedCamPos.copy(desiredCamPos);
      desiredFov = smoothedFov = baseFov;

      locked = false;
      baselineSize = null;

      camera.position.copy(smoothedCamPos);
      camera.lookAt(target);

      const w = wrap.clientWidth, h = wrap.clientHeight;
      if (neonPrimaryMat) neonPrimaryMat.resolution.set(w, h);
      if (neonHaloMat) neonHaloMat.resolution.set(w, h);

      await initFaceLandmarker();
      requestAnimationFrame(onFrame);
    } catch (e) {
      console.error(e);
      statusEl.textContent = "エラー（カメラ許可・CDN・モデル・顔追跡）";
      msgEl.textContent = String(e);
    }
  })();
</script>
</body>
</html>
